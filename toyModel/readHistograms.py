
import copy
from Unfolder.Histogram import H1D, H2D
import numpy as np
import pickle
import json

'''
Read unfolding factors, deciding whether to use the JSON format or the PKL format based on the file name.
'''
def getHistograms(fname = "toyModel/ModelChris.json", direc = "A"):
  if '.json' in fname:
    return getHistogramsFromJson(fname, direc)
  return getHistogramsFromPkl

'''
Read unfolding factors from JSON format
'''
def getHistogramsFromJson(fname = "toyModel/ModelChris.json", direc = "A"):
  parsed_json = json.load(open(fname))

  recoWithFakes = H1D(np.asarray(parsed_json["Data"]))
  bkg = H1D(np.zeros(len(parsed_json["Data"])))

  if direc == "A":
    mig = H2D(np.asarray(parsed_json["Nominal"]["Mig"]))
  else:
    mig = H2D(np.asarray(parsed_json["resolution"]["Variation"]["Mig"]))
  # input assumed to have reco in X axis and truth in Y, so transpose it to the truth in X axis convention
  #mig = mig.T()

  truth_a = []
  for i in range(mig.val.shape[0]):
    truth_a.append(parsed_json["ModelVars"]["truthbin%d" % i]["InitialValue"])
  truth = H1D(np.asarray(truth_a))

  tr_1dtruth = mig.project('x')
  nrt = truth - tr_1dtruth

  ones = H1D(np.ones(len(nrt.val)))
  ones.err = copy.deepcopy(np.zeros(len(nrt.val)))
  ones.x = copy.deepcopy(nrt.x)
  ones.x_err = copy.deepcopy(nrt.x_err)
  eff = ones + nrt.divideBinomial(truth)*(-1.0)
  #eff = mig.project('x').divideBinomial(truth)
  return [truth, recoWithFakes, bkg, mig, eff, nrt]
  
'''
Read unfolding factors from pkl format as generated by toyModel/generateHistograms.py
'''
def getHistogramsFromPkl(fname = "histograms.pkl", direc = "A"):
  m = None
  with open(fname, 'rb') as inp:
    model = pickle.load(inp)
    while model != None:
      if model["name"] != direc:
        model = pickle.load(inp)
        continue
      m = model
      break
  
  truth = m["truth"]
  recoWithFakes = m["reco"]
  # input assumed to have reco in X axis and truth in Y, so transpose it to the truth in X axis convention
  mig = m["mig"].T()

  # fakes
  bkg = m["bkg"]

  tr_1dtruth = mig.project('x')
  nrt = truth - tr_1dtruth

  ones = H1D(np.ones(len(nrt.val)))
  ones.err = copy.deepcopy(np.zeros(len(nrt.val)))
  ones.x = copy.deepcopy(nrt.x)
  ones.x_err = copy.deepcopy(nrt.x_err)
  eff = ones + nrt.divideBinomial(truth)*(-1.0)
  #eff = mig.project('x').divideBinomial(truth)

  return [truth, recoWithFakes, bkg, mig, eff, nrt]

